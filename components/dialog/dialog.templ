package dialog

// Dialog container - native HTML dialog element with Datastar refs and state tracking
templ Dialog(props DialogProps) {
	{{
		// Create nested signal structure: {[id]: {open: false, returnValue: null}}
		signalsJSON := "{\"" + props.ID + "\": {\"open\": false, \"returnValue\": null}}"

		// Create dynamic data-ref attribute name (lowercase to match HTML behavior)
		refAttrName := "data-ref-" + props.ID + "dialog"
		dialogAttrs := templ.Attributes{
			refAttrName: "", // data-ref just needs to exist, value doesn't matter
		}

		// Merge with user-provided attributes
		for k, v := range props.Attributes {
			dialogAttrs[k] = v
		}

		// Add closedby attribute if specified
		if props.ClosedBy != "" {
			dialogAttrs["closedby"] = props.ClosedBy
		}

		// Add event handlers for native dialog events to sync signals
		toggleHandler := "$" + props.ID + ".open = evt.newState === 'open'"
		closeHandler := "$" + props.ID + ".open = false; $" + props.ID + ".returnValue = evt.target.returnValue"

		dialogAttrs["data-on-toggle"] = toggleHandler
		dialogAttrs["data-on-close"] = closeHandler
	}}
	<div data-signals={ signalsJSON }>
		<dialog
			id={ props.ID }
			{ dialogAttrs... }
			class={ props.Class }
		>
			{ children... }
		</dialog>
	</div>
}

// DialogTrigger - button or element that opens the dialog using native methods
templ DialogTrigger(props DialogTriggerProps) {
	{{
		// Create click handler using the dialog ref and update signal
		var clickHandler string
		dialogRef := "$" + props.DialogID + "dialog"
		openSignal := "$" + props.DialogID + ".open = true"

		if props.Modal {
			clickHandler = openSignal + "; " + dialogRef + ".showModal()"
		} else {
			clickHandler = openSignal + "; " + dialogRef + ".show()"
		}
	}}
	if props.AsChild {
		// When AsChild is true, we apply the click handler to the child element
		<div
			data-on-click={ clickHandler }
			{ props.Attributes... }
			class={ props.Class }
		>
			{ children... }
		</div>
	} else {
		<button
			type="button"
			data-on-click={ clickHandler }
			{ props.Attributes... }
			class={ props.Class }
		>
			{ children... }
		</button>
	}
}

// DialogContent - wrapper for dialog content (for backwards compatibility with existing code)
templ DialogContent(props DialogContentProps) {
	{{
		contentClasses := DialogContentVariants(props)

		// Create dynamic data-ref attribute name (lowercase to match HTML behavior)
		refAttrName := "data-ref-" + props.ID + "dialog"
		dialogAttrs := templ.Attributes{
			refAttrName: "", // data-ref just needs to exist
		}

		// Merge with user-provided attributes
		for k, v := range props.Attributes {
			dialogAttrs[k] = v
		}

		// Add native dialog event handlers to sync signals
		toggleHandler := "$'" + props.ID + "'.open = evt.newState === 'open'"
		closeHandler := "$'" + props.ID + "'.open = false; $'" + props.ID + "'.returnValue = evt.target.returnValue"

		dialogAttrs["data-on-toggle"] = toggleHandler
		dialogAttrs["data-on-close"] = closeHandler

		// Add outside click handler if overlay is shown
		if props.ShowOverlay {
			outsideClickHandler := "$" + props.ID + ".open = false; $" + props.ID + "dialog.close('outside-click')"
			dialogAttrs["data-on-click__outside"] = outsideClickHandler
		}

		// Create signals for this dialog instance
		signalsJSON := "{\"" + props.ID + "\": {\"open\": false, \"returnValue\": null}}"
	}}
	<div data-signals={ signalsJSON }>
		<dialog
			id={ props.ID }
			{ dialogAttrs... }
			role="dialog"
			aria-modal="true"
			class={ contentClasses }
		>
			@DialogClose(DialogCloseProps{
				DialogID: props.ID,
				Class:    DialogCloseVariants(DialogCloseProps{DialogID: props.ID}),
			}) {
				<!-- Close button icon -->
				<svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
				</svg>
				<span class="sr-only">Close</span>
			}
			{ children... }
		</dialog>
	</div>
}

// DialogOverlay - backdrop overlay (for styling compatibility - native dialog uses ::backdrop)
templ DialogOverlay(props DialogOverlayProps) {
	<div
		id={ props.ID }
		class={ DialogOverlayVariants(props) }
		{ props.Attributes... }
	></div>
}

// DialogHeader - header section of the dialog
templ DialogHeader(props DialogHeaderProps) {
	<div class={ DialogHeaderVariants(props) } { props.Attributes... }>
		{ children... }
	</div>
}

// DialogFooter - footer section of the dialog
templ DialogFooter(props DialogFooterProps) {
	<div class={ DialogFooterVariants(props) } { props.Attributes... }>
		{ children... }
	</div>
}

// DialogTitle - title element in the dialog header
templ DialogTitle(props DialogTitleProps) {
	<h2 class={ DialogTitleVariants(props) } { props.Attributes... }>
		{ children... }
	</h2>
}

// DialogDescription - description element in the dialog header
templ DialogDescription(props DialogDescriptionProps) {
	<p class={ DialogDescriptionVariants(props) } { props.Attributes... }>
		{ children... }
	</p>
}

// DialogClose - button that closes the dialog using native close() method
templ DialogClose(props DialogCloseProps) {
	{{
		// Create click handler using the dialog ref and update signal
		dialogRef := "$" + props.DialogID + "dialog"
		closeSignal := "$" + props.DialogID + ".open = false"

		var clickHandler string
		if props.ReturnValue != "" {
			clickHandler = closeSignal + "; " + dialogRef + ".close('" + props.ReturnValue + "')"
		} else {
			clickHandler = closeSignal + "; " + dialogRef + ".close()"
		}
	}}
	if props.AsChild {
		// When AsChild is true, we apply the click handler to the child element
		<div
			data-on-click={ clickHandler }
			{ props.Attributes... }
			class={ props.Class }
		>
			{ children... }
		</div>
	} else {
		<button
			type="button"
			data-on-click={ clickHandler }
			{ props.Attributes... }
			class={ props.Class }
		>
			{ children... }
		</button>
	}
}
