---
description: 
globs: *.templ
alwaysApply: false
---
# Datastar Guide: From Alpine.js to DataStar

This guide will help you transition from Alpine.js to Datastar, exploring the similarities and differences while providing practical examples of both frameworks side by side.

## Table of Contents

1. [Introduction](mdc:#introduction)
2. [Installation](mdc:#installation)
3. [Core Concepts: State and Reactivity](mdc:#core-concepts-state-and-reactivity)
4. [Conditional Display](mdc:#conditional-display)
5. [Event Handling](mdc:#event-handling)
   - [Mouse Events](mdc:#mouse-events)
   - [Keyboard Events](mdc:#keyboard-events)
   - [Event Modifiers](mdc:#event-modifiers)
6. [The Big Difference: Backend Integration with Server-Sent Events (SSE)](mdc:#the-big-difference-backend-integration-with-server-sent-events-sse)
7. [Making HTTP Requests with Server-Sent Events](mdc:#making-http-requests-with-server-sent-events)
8. [Advanced Features](mdc:#advanced-features)
9. [Key Differences Summary](mdc:#key-differences-summary)
10. [When to Choose Datastar Over Alpine.js](mdc:#when-to-choose-datastar-over-alpinejs)
11. [Conclusion](mdc:#conclusion)

## Introduction

Datastar brings together frontend reactivity (like Alpine.js) and backend reactivity (like htmx) into one cohesive solution. If you're already familiar with Alpine.js, you'll find many similarities in how DataStar handles reactivity on the frontend, but with the added benefit of backend integration.

## Core Concepts: State and Reactivity

### Creating and Managing State

#### Alpine.js

Alpine.js uses the `x-data` directive to create a component with local state:

```html
<div x-data="{ input: '' }">
  <input type="text" x-model="input" />
  <div x-text="input"></div>
</div>
```

#### Datastar

Datastar uses data attributes to create signals (reactive variables):

```html
<!-- Option 1: Using data-bind-signalName -->
<input data-bind-input />
<div data-text="$input"></div>

<!-- Option 2: Using data-bind="signalName" -->
<input data-bind="input" />
<div data-text="$input"></div>

<!-- Or explicitly create signals -->
<div data-signals-input=""></div>
```

In Datastar, signals are globally accessible throughout your app, prefixed with `$`. Unlike Alpine, which has scoped components, DataStar uses a more flat architecture with global signals.

### Two-Way Data Binding

#### Alpine.js

```html
<div x-data="{ input: '' }">
  <input type="text" x-model="input" />
  <p>Hello, <span x-text="input"></span>!</p>
</div>
```

#### Datastar

```html
<input data-bind-input />
<p>Hello, <span data-text="$input"></span>!</p>
```

### Conditional Display

#### Alpine.js

```html
<div x-data="{ show: false }">
  <button @click="show = !show">Toggle</button>

  <!-- Using x-show (similar to display: none) -->
  <p x-show="show">This content appears when show is true</p>

  <!-- Using x-if (removes from DOM) -->
  <template x-if="show">
    <p>This content is only in the DOM when show is true</p>
  </template>
</div>
```

#### Datastar

```html
<div data-signals-show="false">
  <button data-on-click="$show = !$show">Toggle</button>

  <!-- Similar to x-show -->
  <p data-show="$show">This content appears when show is true</p>
</div>
```

### Computed Properties

#### Alpine.js

```html
<div
  x-data="{ input: '', get uppercase() { return this.input.toUpperCase() } }"
>
  <input type="text" x-model="input" />
  <p x-text="uppercase"></p>
</div>
```

#### Datastar

```html
<input data-bind-input />
<div data-computed-uppercase="$input.toUpperCase()">
  <p data-text="$uppercase"></p>
</div>
```

### Class Manipulation

#### Alpine.js

```html
<div x-data="{ input: '' }">
  <input type="text" x-model="input" />
  <button x-bind:class="{ 'hidden': input === '', 'font-bold': input === '1' }">
    Save
  </button>
</div>
```

#### Datastar

```html
<input data-bind-input />
<button data-class="{hidden: $input === '', 'font-bold': $input === '1'}">
  Save
</button>

<!-- Alternative for a single class -->
<button data-class-hidden="$input === ''">Save</button>
```

### Attribute Binding

#### Alpine.js

```html
<div x-data="{ input: '' }">
  <input type="text" x-model="input" />
  <button x-bind:disabled="input === ''">Save</button>
</div>
```

#### Datastar

```html
<input data-bind-input />
<button data-attr-disabled="$input === ''">Save</button>

<!-- Alternative for multiple attributes -->
<button data-attr="{disabled: $input === '', title: $input}">Save</button>
```

## Event Handling

### Mouse Events

Both Alpine.js and Datastar provide mechanisms for handling mouse events, but with slightly different syntax and capabilities.

#### Alpine.js

Alpine.js uses the `@` prefix for event binding:

```html
<div x-data="{ count: 0 }">
  <!-- Basic click event -->
  <button @click="count++">Increment</button>

  <!-- Mouse events -->
  <div @mouseover="console.log('Mouse over')">Hover over me</div>
  <div @mouseenter="console.log('Mouse entered')">Enter me</div>
  <div @mouseleave="console.log('Mouse left')">Leave me</div>
</div>
```

#### Datastar

Datastar uses the `data-on-` prefix followed by the event name:

```html
<div data-signals-count="0">
  <!-- Basic click event -->
  <button data-on-click="$count++">Increment</button>

  <!-- Mouse events -->
  <div data-on-mouseover="console.log('Mouse over')">Hover over me</div>
  <div data-on-mouseenter="console.log('Mouse entered')">Enter me</div>
  <div data-on-mouseleave="console.log('Mouse left')">Leave me</div>
</div>
```

In Datastar, you have access to the native event object through the `evt` variable in your expressions:

```html
<div data-on-mousemove="console.log(evt.clientX, evt.clientY)">
  Move your mouse here to see coordinates
</div>
```

### Keyboard Events

Handling keyboard events is where Datastar's approach offers more flexibility compared to Alpine.js.

#### Alpine.js

Alpine.js uses event modifiers for common keyboard events:

```html
<div x-data="{ message: '' }">
  <!-- Listen for Enter key press -->
  <input x-model="message" @keydown.enter="alert('Enter pressed')" />

  <!-- Listen for Escape key press -->
  <input x-model="message" @keydown.escape="message = ''" />

  <!-- Listen for key combinations -->
  <div @keydown.ctrl.s.prevent="saveData()">Press Ctrl+S to save</div>
</div>
```

#### Datastar

Datastar provides more granular control by giving you direct access to the event object:

```html
<div data-signals-message="''">
  <!-- Listen for Enter key press -->
  <input
    data-bind-message
    data-on-keydown="evt.key === 'Enter' && alert('Enter pressed')"
  />

  <!-- Listen for Escape key press -->
  <input
    data-bind-message
    data-on-keydown="evt.key === 'Escape' && ($message = '')"
  />

  <!-- Listen for key combinations -->
  <div
    data-on-keydown="evt.ctrlKey && evt.key === 's' && (evt.preventDefault(), saveData())"
  >
    Press Ctrl+S to save
  </div>
</div>
```

For global keyboard events (that aren't tied to a specific element), Datastar provides the `__window` modifier:

```html
<!-- Listen for Ctrl+L anywhere on the page -->
<div
  data-on-keydown__window="evt.ctrlKey && evt.key === 'l' && alert('Ctrl+L pressed')"
></div>

<!-- Multiple key combinations in one handler -->
<div
  data-on-keydown__window="(evt.key === 'Enter' || (evt.ctrlKey && evt.key === 'l')) && alert('Hotkey pressed')"
></div>
```

### Event Modifiers

Datastar offers a range of modifiers for event handling.

#### Alpine.js

Alpine.js uses dot notation for event modifiers:

```html
<div x-data>
  <!-- Prevent default behavior -->
  <a href="#" @click.prevent="handleClick()">Click me</a>

  <!-- Stop propagation -->
  <div @click="outerClick()">
    Outer
    <div @click.stop="innerClick()">Inner</div>
  </div>

  <!-- Only trigger once -->
  <button @click.once="setupUser()">Initialize</button>
</div>
```

#### Datastar

In Datastar, you use the event object directly and the JavaScript comma operator for multiple actions:

```html
<!-- Prevent default behavior -->
<a href="#" data-on-click="evt.preventDefault(), handleClick()">Click me</a>

<!-- Stop propagation -->
<div data-on-click="outerClick()">
  Outer
  <div data-on-click="evt.stopPropagation(), innerClick()">Inner</div>
</div>
```

Datastar also supports additional modifiers with the double-underscore syntax:

```html
<!-- Global events with __window -->
<div data-on-scroll__window="handleScroll()"></div>

<!-- Debouncing events -->
<input
  data-bind-search
  data-on-input__debounce.300ms="performSearch($search)"
/>

<!-- Event name casing for custom events -->
<custom-element
  data-on-custom-event__case.camel="handleCustomEvent()"
></custom-element>
```

### Custom Events

Both frameworks support listening for custom events.

#### Alpine.js

```html
<div x-data="{ message: '' }" @custom-event.window="message = $event.detail">
  <p x-text="message"></p>
  <button @click="$dispatch('custom-event', 'Hello from Alpine')">
    Dispatch event
  </button>
</div>
```

#### Datastar

```html
<div
  data-signals-message="''"
  data-on-customevent__window="$message = evt.detail"
>
  <p data-text="$message"></p>
  <button
    data-on-click="window.dispatchEvent(new CustomEvent('customevent', {detail: 'Hello from Datastar'}))"
  >
    Dispatch event
  </button>
</div>
```

For integration with web components or other JavaScript libraries that emit events, Datastar's approach provides greater flexibility by giving you direct access to the event object.

## The Big Difference: Backend Integration with Server-Sent Events (SSE)

This is where Datastar really shines compared to Alpine.js. While Alpine is purely frontend-focused, DataStar integrates with your backend using Server-Sent Events (SSE), a web standard that enables servers to push updates to clients over a single, long-lived HTTP connection.

### How Datastar Uses SSE

Datastar extends the standard SSE protocol (which normally only supports GET requests) to work with all HTTP methods (POST, PUT, PATCH, DELETE), allowing for true bidirectional communication. Here's what happens behind the scenes:

1. When you use actions like `@get()`, `@post()`, etc., Datastar opens a connection to the server
2. The server responds with the MIME type `text/event-stream`
3. The server can then stream multiple events to the client without closing the connection
4. These events can include HTML fragments, signal updates, or script execution commands

Datastar extends SSE by defining specific event types:

- `datastar-merge-fragments`: Updates HTML in the DOM
- `datastar-merge-signals`: Updates signal values
- `datastar-remove-fragments`: Removes elements from the DOM
- `datastar-remove-signals`: Removes signals
- `datastar-execute-script`: Executes JavaScript code

### Basic Example: Click to Edit Pattern

Consider a typical "click to edit" UI pattern:

#### Alpine.js Approach

In Alpine, you'd likely need to:

1. Use AJAX calls manually to fetch data
2. Toggle between view/edit states
3. Handle form submission separately

```html
<div
  x-data="{ 
  contact: { id: 1, firstName: 'John', lastName: 'Doe', email: 'joe@blow.com' },
  editing: false,
  async startEdit() {
    this.editing = true;
  },
  async saveContact() {
    await fetch('/contact/1', {
      method: 'PUT',
      body: JSON.stringify(this.contact)
    });
    this.editing = false;
  }
}"
>
  <!-- View Mode -->
  <template x-if="!editing">
    <div>
      <label>First Name: <span x-text="contact.firstName"></span></label>
      <label>Last Name: <span x-text="contact.lastName"></span></label>
      <label>Email: <span x-text="contact.email"></span></label>
      <div>
        <button @click="startEdit()">Edit</button>
      </div>
    </div>
  </template>

  <!-- Edit Mode -->
  <template x-if="editing">
    <div>
      <div>
        <label>First Name</label>
        <input type="text" x-model="contact.firstName" />
      </div>
      <div>
        <label>Last Name</label>
        <input type="text" x-model="contact.lastName" />
      </div>
      <div>
        <label>Email</label>
        <input type="text" x-model="contact.email" />
      </div>
      <div>
        <button @click="saveContact()">Save</button>
        <button @click="editing = false">Cancel</button>
      </div>
    </div>
  </template>
</div>
```

#### Datastar Approach

With Datastar, the backend controls the UI transitions:

```html
<!-- View Mode -->
<div id="contact_1">
  <label>First Name: John</label>
  <label>Last Name: Doe</label>
  <label>Email: joe@blow.com</label>
  <div>
    <button data-on-click="@get('/contact/1/edit')">Edit</button>
  </div>
</div>
```

When the button is clicked, the server responds with an SSE stream that might look like:

```
event: datastar-merge-fragments
data: fragments
data: <div id="contact_1" data-signals="{id: 1, firstName: 'John', lastName: 'Doe', email: 'joe@blow.com'}">
data:   <div>
data:     <label>First Name</label>
data:     <input type="text" data-bind="firstName" />
data:   </div>
data:   <div>
data:     <label>Last Name</label>
data:     <input type="text" data-bind="lastName" />
data:   </div>
data:   <div>
data:     <label>Email</label>
data:     <input type="text" data-bind="email" />
data:   </div>
data:   <div>
data:     <button data-on-click="@put('/contact/1')">Save</button>
data:     <button data-on-click="@get('/contact/1')">Cancel</button>
data:   </div>
data: </div>
```

The key difference is that with Datastar:

1. The server owns the UI state transitions through SSE events
2. The server can send multiple updates in a single response
3. No need to maintain two separate views in your frontend code
4. Data validation happens on the server
5. When you click Save, all signals are automatically sent to the server
6. The server can react with more SSE events to update other parts of the UI

## Making HTTP Requests with Server-Sent Events

### Alpine.js

Alpine has no built-in HTTP functionality. You need to use `fetch()` or a library:

```html
<div
  x-data="{ 
  async fetchData() {
    const response = await fetch('/api/data');
    const data = await response.json();
    // Do something with data
  }
}"
>
  <button @click="fetchData()">Fetch Data</button>
</div>
```

### Datastar

Datastar has built-in actions for HTTP requests that leverage the extended SSE protocol:

```html
<button data-on-click="@get('/api/data')">Fetch Data</button>
<button data-on-click="@post('/api/data')">Submit Data</button>
<button data-on-click="@put('/api/data')">Update Data</button>
<button data-on-click="@patch('/api/data')">Patch Data</button>
<button data-on-click="@delete('/api/data')">Delete Data</button>

<!-- With loading indicator -->
<button data-on-click="@get('/api/data')" data-indicator-loading>
  Fetch Data
</button>
<div data-class-loading="$loading">Loading...</div>
```

When these actions are triggered, Datastar:

1. Sends the HTTP request to the server
2. Establishes an SSE connection
3. Receives a stream of events from the server
4. Processes these events to update the DOM and signals

Unlike traditional AJAX where you get a single response, Datastar's SSE integration allows the server to send multiple events in response to a single request:

```javascript
// Server-side example (Node.js)
app.get("/api/data", (req, res) => {
  // Set up SSE headers
  res.writeHead(200, {
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
  });

  // Send multiple events in sequence
  res.write("event: datastar-merge-fragments\n");
  res.write("data: fragments\n");
  res.write('data: <div id="status">Loading data...</div>\n\n');

  // After some processing...
  setTimeout(() => {
    res.write("event: datastar-merge-fragments\n");
    res.write("data: fragments\n");
    res.write('data: <div id="status">Processing complete!</div>\n\n');

    res.write("event: datastar-merge-signals\n");
    res.write('data: {results: ["item1", "item2", "item3"]}\n\n');

    // Close the connection when done
    res.end();
  }, 1000);
});
```

This approach enables real-time updates and progressive UI enhancements without complex client-side code.

## Advanced Features

### Batch Operations

#### Alpine.js

```html
<div x-data="{ checkboxes: { one: false, two: false, three: false } }">
  <input type="checkbox" x-model="checkboxes.one" /> One
  <input type="checkbox" x-model="checkboxes.two" /> Two
  <input type="checkbox" x-model="checkboxes.three" /> Three

  <button
    @click="Object.keys(checkboxes).forEach(key => checkboxes[key] = true)"
  >
    Check All
  </button>
  <button
    @click="Object.keys(checkboxes).forEach(key => checkboxes[key] = !checkboxes[key])"
  >
    Toggle All
  </button>
</div>
```

#### Datastar

```html
<input type="checkbox" data-bind-checkboxes.one /> One
<input type="checkbox" data-bind-checkboxes.two /> Two
<input type="checkbox" data-bind-checkboxes.three /> Three

<button data-on-click="@setAll('checkboxes.*', true)">Check All</button>
<button data-on-click="@toggleAll('checkboxes.*')">Toggle All</button>
```

### Building a Dropdown Menu Component

Let's implement a dropdown menu to demonstrate how Datastar handles common UI patterns that typically require a combination of state management and event handling.

#### Basic Dropdown Implementation

```html
<div
  data-signals-dropdown.isOpen="false"
  data-ref-dropdown_container
  data-on-click__window="
    $dropdown.isOpen && 
    !$dropdown_container.contains(evt.target) && 
    ($dropdown.isOpen = false)
  "
>
  <!-- Dropdown Toggle Button -->
  <button
    data-on-click="$dropdown.isOpen = !$dropdown.isOpen"
    aria-expanded="true"
    data-attr-aria-expanded="$dropdown.isOpen"
  >
    Menu <span data-text="$dropdown.isOpen ? '▲' : '▼'"></span>
  </button>

  <!-- Dropdown Content -->
  <div data-show="$dropdown.isOpen" class="dropdown-menu" style="display: none">
    <a href="#" class="dropdown-item">Profile</a>
    <a href="#" class="dropdown-item">Settings</a>
    <a href="#" class="dropdown-item">Logout</a>
  </div>
</div>
```

In this example:

1. **State Management**: We use a namespaced signal `dropdown.isOpen` to track the open/closed state
2. **Click Outside**: We implement click-outside behavior using `data-on-click__window` combined with a reference to the container
3. **Accessibility**: We maintain the `aria-expanded` attribute with `data-attr-aria-expanded`
4. **Conditional Display**: We show/hide the dropdown content with `data-show`
5. **Visual Indicator**: We change the dropdown arrow direction based on the state

#### Advanced Dropdown with Keyboard Navigation

```html
<div
  data-signals="{
    dropdown: {
      isOpen: false,
      selectedIndex: -1,
      items: [
        {label: 'Profile', url: '/profile'},
        {label: 'Settings', url: '/settings'},
        {label: 'Logout', url: '/logout'}
      ]
    }
  }"
  data-ref-dropdown_container
  data-on-click__window="
    $dropdown.isOpen && 
    !$dropdown_container.contains(evt.target) && 
    ($dropdown.isOpen = false)
  "
  data-on-keydown__window="
    $dropdown.isOpen && (
      evt.key === 'ArrowDown' && (
        evt.preventDefault(), 
        $dropdown.selectedIndex = Math.min($dropdown.selectedIndex + 1, $dropdown.items.length - 1)
      ),
      evt.key === 'ArrowUp' && (
        evt.preventDefault(), 
        $dropdown.selectedIndex = Math.max($dropdown.selectedIndex - 1, 0)
      ),
      evt.key === 'Enter' && $dropdown.selectedIndex >= 0 && (
        evt.preventDefault(),
        window.location.href = $dropdown.items[$dropdown.selectedIndex].url,
        $dropdown.isOpen = false
      ),
      evt.key === 'Escape' && (
        evt.preventDefault(), 
        $dropdown.isOpen = false
      )
    )
  "
>
  <!-- Dropdown Toggle Button -->
  <button
    data-on-click="$dropdown.isOpen = !$dropdown.isOpen; $dropdown.selectedIndex = -1;"
    aria-expanded="true"
    data-attr-aria-expanded="$dropdown.isOpen"
  >
    Menu <span data-text="$dropdown.isOpen ? '▲' : '▼'"></span>
  </button>

  <!-- Dropdown Content -->
  <div data-show="$dropdown.isOpen" class="dropdown-menu" style="display: none">
    <div data-on-click="$dropdown.isOpen = false">
      <a
        href="#"
        data-attr-href="item.url"
        data-on-mouseenter="$dropdown.selectedIndex = index"
        data-class-active="$dropdown.selectedIndex === index"
        data-signals="{item: item, index: index}"
        class="dropdown-item"
        data-text="item.label"
      ></a>
    </div>
  </div>
</div>
```

This enhanced version adds:

1. **Keyboard Navigation**: Using arrow keys to navigate items
2. **Item Selection**: Tracking the selected item with `selectedIndex`
3. **Dynamic Menu Items**: Generating menu items from a data array
4. **Visual Indicators**: Adding an active class based on selection state

#### Server-Integrated Dropdown

For more dynamic dropdowns where content is loaded from the server:

```html
<div
  data-signals-dropdown.isOpen="false"
  data-ref-dropdown_container
  data-on-click__window="
    $dropdown.isOpen && 
    !$dropdown_container.contains(evt.target) && 
    ($dropdown.isOpen = false)
  "
>
  <!-- Dropdown Toggle Button -->
  <button
    data-on-click="
      $dropdown.isOpen = !$dropdown.isOpen;
      $dropdown.isOpen && @get('/api/menu-items')
    "
    aria-expanded="true"
    data-attr-aria-expanded="$dropdown.isOpen"
    data-indicator-loading
  >
    Menu
    <span data-show="!$loading" data-text="$dropdown.isOpen ? '▲' : '▼'"></span>
    <span data-show="$loading">...</span>
  </button>

  <!-- Dropdown Content -->
  <div
    id="dropdown-menu-content"
    data-show="$dropdown.isOpen"
    class="dropdown-menu"
    style="display: none"
  >
    <!-- Content will be loaded from server -->
  </div>
</div>
```

The server response would look like:

```
event: datastar-merge-fragments
data: selector #dropdown-menu-content
data: fragments
data: <a href="/profile" class="dropdown-item">Profile</a>
data: <a href="/settings" class="dropdown-item">Settings</a>
data: <a href="/logout" class="dropdown-item">Logout</a>
```

#### Dropdown with Submenu

For nested dropdown menus:

```html
<div
  data-signals="{
  dropdown: {
    isOpen: false,
    submenu: {
      isOpen: false,
      hoverTimer: null
    }
  }
}"
>
  <!-- Main dropdown toggle -->
  <button data-on-click="$dropdown.isOpen = !$dropdown.isOpen">
    Menu <span data-text="$dropdown.isOpen ? '▲' : '▼'"></span>
  </button>

  <!-- Main dropdown content -->
  <div data-show="$dropdown.isOpen" class="dropdown-menu" style="display: none">
    <a href="#" class="dropdown-item">Profile</a>

    <!-- Submenu parent -->
    <div
      data-on-mouseenter="
        $dropdown.submenu.hoverTimer = setTimeout(() => { 
          $dropdown.submenu.isOpen = true 
        }, 200)
      "
      data-on-mouseleave="
        clearTimeout($dropdown.submenu.hoverTimer);
        $dropdown.submenu.hoverTimer = setTimeout(() => { 
          $dropdown.submenu.isOpen = false 
        }, 200)
      "
      class="dropdown-item with-submenu"
    >
      Settings <span data-text="$dropdown.submenu.isOpen ? '◄' : '►'"></span>

      <!-- Submenu content -->
      <div
        data-show="$dropdown.submenu.isOpen"
        class="submenu"
        style="display: none"
      >
        <a href="#" class="dropdown-item">Account</a>
        <a href="#" class="dropdown-item">Preferences</a>
        <a href="#" class="dropdown-item">Notifications</a>
      </div>
    </div>

    <a href="#" class="dropdown-item">Logout</a>
  </div>
</div>
```

This example demonstrates:

1. **Nested State Management**: Using namespaced signals for main dropdown and submenu states
2. **Hover Delays**: Implementing hover delays for better UX when opening/closing submenus
3. **Visual Indicators**: Showing different icons based on open/closed states

### Dropdown Implementation Notes

When implementing dropdowns with Datastar, consider these key points:

1. **Signal Structure**: Choose between global signals or namespaced/component-specific signals based on your needs:

   - Global signals (`data-signals-dropdown_open="false"`) are simpler but can conflict across multiple dropdowns
   - Namespaced signals (`data-signals-dropdown.isOpen="false"`) provide better organization and isolation

2. **Click-Outside Detection**: In Alpine.js, you'd use `@click.away`, but in Datastar you can achieve this with:

   ```html
   <div
     data-ref-dropdown_el
     data-on-click__window="
       $dropdown.isOpen && 
       !$dropdown_el.contains(evt.target) && 
       ($dropdown.isOpen = false)
     "
   ></div>
   ```

3. **Hover States and Timing**: For menus with hover effects, implement timers directly in expressions:

   ```html
   data-on-mouseenter="$hoverTimer = setTimeout(() => { $submenu.isOpen = true
   }, 200)" data-on-mouseleave="clearTimeout($hoverTimer); $submenu.isOpen =
   false"
   ```

4. **Keyboard Navigation**: Handle keyboard events with window-level event listeners:

   ```html
   data-on-keydown__window=" $dropdown.isOpen && ( evt.key === 'ArrowDown' &&
   (evt.preventDefault(), navigateDown()), evt.key === 'Escape' &&
   (evt.preventDefault(), closeDropdown()) ) "
   ```

5. **Server Integration**: For dynamic content, use the backend plugin actions and SSE events:

   ```html
   <button data-on-click="@get('/api/menu-items')">Load Menu</button>
   ```

6. **Portal/Teleport**: Use server-side rendering with targeted fragments for complex positioning needs:
   ```
   event: datastar-merge-fragments
   data: selector #portal-target
   data: fragments <div class="dropdown-content">...</div>
   ```

Unlike Alpine.js where you'd typically need to implement all dropdown functionality on the client side, Datastar allows you to choose which parts to handle client-side for responsiveness and which parts to delegate to the server for more complex logic or dynamic content.

## Key Differences Summary

1. **Architecture**:

   - Alpine.js: Component-based with scoped state
   - Datastar: Global signals with prefix notation

2. **Backend Integration**:

   - Alpine.js: None built-in, requires manual AJAX
   - Datastar: Built-in Server-Sent Events (SSE) integration with extensions for all HTTP methods

3. **SSE Events in Datastar**:

   - `datastar-merge-fragments`: Updates HTML in the DOM
   - `datastar-merge-signals`: Updates signal values
   - `datastar-remove-fragments`: Removes elements from the DOM
   - `datastar-remove-signals`: Removes signals
   - `datastar-execute-script`: Executes JavaScript code

4. **HTTP Actions**:

   - Alpine.js: None built-in
   - Datastar: Built-in actions for GET, POST, PUT, PATCH, DELETE that use extended SSE

5. **UI Control**:

   - Alpine.js: Frontend controls the UI
   - Datastar: Backend can control and update the UI through SSE events

6. **Syntax**:

   - Alpine.js: x-prefixed directives (x-data, x-model, etc.)
   - Datastar: data-prefixed attributes (data-bind, data-text, etc.)

7. **State Management**:
   - Alpine.js: Local component state
   - Datastar: Global signal-based state that can be updated from the server

## When to Choose Datastar Over Alpine.js

1. When you want seamless backend integration with real-time updates
2. When your server needs to control UI state transitions
3. When you want simpler HTTP interactions with streaming responses
4. When you prefer a more hypermedia-driven approach
5. When you want progressive UI updates without complex client-side code
6. When you need both client-side reactivity and server-driven UI updates

## Conclusion

Datastar provides a powerful alternative to Alpine.js with built-in backend integration. If you're used to Alpine.js, the transition should be smooth since many concepts are similar, but with slightly different syntax.



The biggest advantage of Datastar is the tight backend integration via Server-Sent Events, allowing your server to control UI state transitions and update the DOM in a more declarative way.